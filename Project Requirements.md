# 轻量级本地 Web/HTTP 框架需求分析
## 1. 概述
本项目旨在构建一个轻量级的本地 Web/HTTP 框架。  
核心要求是能够以最少的依赖在本地环境中启动一个 HTTP 服务。  
框架需具备灵活的路由、可扩展的中间件机制以及统一的请求处理上下文。

### 1.1. 什么是 Web 框架？
在我们开始编码之前，理解我们正在构建的东西至关重要。  
我们要构建的是一个“Web 框架”。

可以把 Web 框架想象成一个脚手架或者一个半成品的房子。  
当你需要建造一座房子时，你不需要从零开始制造砖块、水泥和钢筋。  
你可以使用预制好的构件，并遵循一套成熟的建筑图纸和流程。

同样，在开发一个Web应用的时候，我们也需要一系列“预置”了Web开发流程的“代码槽”，让我们只需要在在预置的”代码槽“里填入我们自己独特的业务流程就好了。这一系列“代码槽”就是Web 框架。Web 框架为开发者提供了一套标准的工具、组件和规则，用于构建 Web 应用程序。它处理了许多通用的、重复性的任务，例如：

+ **监听和响应网络请求**：如何接收来自浏览器的 HTTP 请求并向其发送回一个响应？
+ **路由（Routing）**：如何根据用户访问的 URL（例如 `/home` 或 `/users/123`）来决定执行哪一段代码？
+ **数据处理**：如何解析用户提交的数据？如何组织和管理响应内容？

通过使用框架，开发者可以将精力集中在应用程序的**核心业务逻辑**上——也就是那些让你的应用与众不同的独特功能——而不是一遍又一遍地“重新发明轮子”。

### 1.2 Web框架的例子
让我们通过一个具体的例子来看看 Web 框架是如何工作的。假设你在浏览器中输入地址 `http://localhost:8080/hello` 并按下回车。

1. **监听与接收**：你的 Web 框架（会被具象化作为一个服务器程序）将一直在本地计算机的 `8080` 端口上“监听”。当浏览器发送请求时，框架的底层网络模块会捕捉到这个信号，并读取其中包含的原始 HTTP 请求数据。
2. **解析请求**：框架会将原始的请求数据（一长串文本）解析成一个结构化的、易于使用的对象。这个对象里包含了所有关键信息，例如请求方法（是 `GET` 还是 `POST`？）、请求的路径（`/hello`）、浏览器类型等。
3. **路由分发**：框架的核心组件之一——**路由器**——会检查请求的路径 `/hello`。它会在你预先定义的“路由表”中进行查找，寻找与 `/hello` 匹配的规则。
4. **执行处理器**：一旦找到匹配的路由规则，框架就会调用与该规则关联的特定业务逻辑代码，我们通常称之为**处理器（Handler）**。同时，框架会将第二步中解析好的请求对象传递给这个处理器，以便你访问请求的详细信息。
5. **处理业务逻辑**：现在，轮到你编写的处理器代码大显身手了。对于这个简单的例子，它的任务可能只是准备一个字符串，比如 "Hello, World!"。对于复杂的例子，它的任务可能是从数据库中获取数据、处理用户输入、调用外部服务等。
6. **构建响应**：处理器将结果（"Hello, World!"）交给框架。框架会用这个结果来构建一个标准的 HTTP 响应，包括设置状态码（例如 `200 OK`，表示成功）、响应内容的类型（例如 `Content-Type: text/plain`）以及最终的响应内容本身。
7. **发送响应**：最后，框架通过底层的网络模块将这个完整的 HTTP 响应发送回浏览器。
8. **浏览器渲染**：浏览器接收到响应后，就会将内容（"Hello, World!"）显示在页面上。

通过这个流程，你可以看到，框架为你处理了所有与网络通信、协议解析、请求分发相关的繁琐工作。作为开发者，你只需要关注第 5 步：定义路由规则并编写处理具体业务逻辑的处理器。这就是框架的核心价值所在。

### 总结
在这个项目中，你将亲手构建一个**微型框架**。  
它虽然不具备像 Spring 或 Django 那样大型框架的全部功能，但它包含了所有最核心、最本质的组件。完成这个项目后，你将对面向对象程序设计原理有更深刻的理解，同时也将对 Web 框架的内部工作原理有更深刻的把握。



## 2. 核心功能需求
### 2.1. HTTP 服务
#### 2.1.1. 什么是 HTTP？
HTTP，全称**超文本传输协议（HyperText Transfer Protocol）**，是互联网上应用最广泛的一种网络协议。你可以把它想象成是浏览器（客户端）和服务器之间沟通时必须遵守的“语言”和“规则”。当你打开浏览器访问一个网站时，浏览器就会使用 HTTP 协议向网站的服务器发送一个请求，服务器在处理完这个请求后，也会通过 HTTP 协议将网页内容（HTML、CSS、JavaScript、图片等）返回给浏览器。

#### 2.1.2. 什么是 HTTP 服务？
一个 **HTTP 服务**（或称 HTTP 服务器、Web 服务器）就是一个持续运行的计算机程序，它的主要职责是“监听”特定网络端口（比如 80 或 8080 端口）上的 HTTP 请求，并根据请求的内容给予响应。



#### 2.1.3. 什么是 HTTP 请求？
一个 HTTP 请求就像是客户端发给服务器的一封“信件”，它包含了客户端想要做什么以及需要什么资源的信息。这封信主要由以下几个部分组成：

1. **请求方法（Method）**：表明希望对资源执行的操作类型。常见的类型有：
    - `GET`：获取资源。比如访问一个网页、查看一篇文章。这是最常见的请求类型。
    - `POST`：创建资源。比如提交一个注册表单、发布一篇文章。通常会把需要提交的数据放在请求体中。
    - `PUT`：更新资源。比如修改一篇完整的文章内容。
    - `DELETE`：删除资源。比如删除一篇文章。
2. **URL（Uniform Resource Locator）**：指明要操作的资源在服务器上的位置。例如 `127.0.0.1:8080/users/123`。
3. **HTTP 版本**：通常是 `HTTP/1.1`。
4. **请求头（Headers）**：包含关于请求的附加信息，例如客户端类型、期望接收的数据格式等。
5. **请求体（Body）**：可选部分。当使用 `POST` 或 `PUT` 等方法时，通常会在这里存放要提交给服务器的数据（例如 JSON、表单数据）。`GET` 请求通常没有请求体。

#### 2.1.4. HTTP 服务器如何处理请求？
当我们的 HTTP 服务器收到一个请求后，它会像一个训练有素的接待员一样，按照以下流程进行处理：

1. **解析请求**：读取并理解这封“信件”的内容，弄清楚客户端的请求方法、想访问的 URL 以及附带的数据。
2. **路由分发**：根据请求的 URL，将其分发给专门处理该路径的业务逻辑代码（这正是我们将在 `2.2. 路由系统` 中详细讨论的）。
3. **处理业务**：执行相应的业务逻辑，这可能包括查询数据库、进行计算、调用其他服务等。
4. **构建响应**：将处理结果打包成一封“回信”，即 HTTP 响应。响应也包含状态码（如 `200 OK` 表示成功，`404 Not Found` 表示未找到资源）、响应头和响应体（例如 HTML 页面或 JSON 数据）。
5. **发送响应**：将构建好的响应发送回客户端。

#### 2.1.5. 项目实现要求
+ **本地启动**：项目应支持一键启动 HTTP 服务，对外部依赖降至最低，方便开发和测试。
+ **底层技术**：我们将基于 **Netty** 来构建这个 HTTP 服务。Netty 是一个高性能的异步事件驱动的网络应用框架，它能让我们更高效地处理网络通信的底层细节。

### 2.2. 路由系统（Router）
+ **请求方法**：必须支持 `GET` 和 `POST` 请求。
+ **路径匹配**：
    - **静态路径**：例如 `/about`。
    - **动态参数**：支持 `:param` 形式的路径参数，例如 `/users/:id`。
    - **通配符**：支持 `*` 通配符，例如 `/static/*`。
+ **匹配逻辑**：路由匹配应采用前缀树（Trie）思想实现，以保证高效查找。
+ **举例说明**: 想象一下，你的网站是一个大型办公楼，里面有许多不同的部门（销售部、市场部、技术支持部等）。当一个访客（一个 HTTP 请求）来到前台时，他需要告诉前台他想去哪个部门（访问哪个 URL）。**路由系统**就扮演着这个“智能前台”的角色。它的核心职责是：**建立 URL 和处理代码之间的映射关系**。  
换句话说，它会查看访客想要访问的 URL 路径（例如 `/products/iphone`），然后根据预先设定的规则，准确地将这个请求“派发”给专门负责处理“产品详情”的那段代码。

**为什么路由系统至关重要？**

如果没有路由，你的应用程序就像一个只有一个大房间的建筑。所有请求都涌入同一个地方，你将需要编写大量混乱的 `if-else` 语句来判断用户到底想干什么。这会导致代码难以维护、扩展和理解。

一个好的路由系统能让你：

+ **组织代码结构**：将不同功能的代码（例如处理用户、处理订单）清晰地分离开来。
+ **创建友好的 URL**：设计出简洁、易于理解且对搜索引擎友好（SEO-friendly）的网址，例如 `/blog/my-first-post` 而不是 `/get_article.jsp?id=123`。
+ **提取动态参数**：从 URL 中方便地获取信息。例如，在 `/users/123` 这个路径中，路由系统可以轻松帮你提取出用户 ID `123`。

**路由的几种常见类型：**

+ **静态路由 (Static Route)**：URL 和处理代码是精确的一对一匹配。
    - `GET /home` -> 调用“显示主页”的处理器。
    - `GET /about` -> 调用“显示关于我们页面”的处理器。
+ **动态路由 (Dynamic/Parameterized Route)**：URL 中包含可变的参数。
    - `GET /users/{id}` -> 可以匹配 `/users/123`、`/users/456` 等。路由器会提取出 `id` 的值（`123` 或 `456`）并传递给处理器。
+ **通配符路由 (Wildcard Route)**：匹配某一模式下的所有路径。
    - `GET /static/*` -> 可以匹配 `/static/css/style.css`、`/static/js/main.js` 等，通常用于提供静态文件。

在这个项目中，你将实现一个支持以上所有功能的、基于**前缀树（Trie）**的高性能路由系统。这将是你整个框架的“交通枢纽”。

### 2.3. 中间件（Middleware）
**1. 概念解析：请求处理的函数式视角**

从本质上讲，Web 框架的核心工作可以抽象为一个函数：`response = f(request)`。它的职责就是接收一个 `request` 对象，经过一系列处理，最终生成一个 `response` 对象。

然而，这个函数 `f` 通常不是一个单一、庞大的整体。一个更优雅、更灵活的设计是将其看作是多个小函数（`f1`, `f2`, `f3`, ...）的**组合**或**嵌套调用**：  
`f(request) = f1(f2(f3(request)))`

**中间件（Middleware）**就是这个函数链中的一环（如 `f1`, `f2`）。它是一个独立的、可复用的功能单元，负责处理一项特定的任务。请求就像一个流水线上的产品，依次流经各个中间件，每个中间件都对其进行一些“加工”，然后传递给下一个，直到最终的业务处理器完成核心工作。

**2. 核心职责与重要性**

+ **横切关注点 (Cross-Cutting Concerns)**：这种函数式组合的结构，是处理“横切关注点”的完美模型。在我们的函数链 `f1(f2(f3(request)))` 中：
    - `f3` 可能是核心的业务逻辑（比如获取文章详情）。
    - `f2` 可能是一个**鉴权中间件**，负责检查用户权限。
    - `f1` 可能是一个**日志中间件**，负责记录请求耗时。  
这样，核心业务逻辑 `f3` 就无需关心日志和鉴权这些与业务无关的功能，保持了代码的纯净和高度内聚。
+ **链式处理与控制**：每个中间件函数都有能力决定是调用下一个函数（放行），还是直接返回一个响应（拦截）。

**3. 代码示例：中间件如何工作**

为了让你有更直观的感受，我们来看两个简单的伪代码示例。假设我们的中间件接口看起来像这样：

```java
// 这是一个函数式接口，你可以用 Lambda 表达式来实现它
interface Middleware {
    void handle(Context context, Next next);
}

// `next` 代表了函数链中的下一个函数，调用它会将控制权传递下去
interface Next {
    void handle(Context context);
}
```

**示例 A：日志中间件 (**`f1`**)**

这个中间件会在请求处理前后打印日志。

```java
// 伪代码
Middleware loggingMiddleware = (context, next) -> {
    long startTime = System.currentTimeMillis();
    System.out.println("==> Request Start: " + context.method() + " " + context.path());

    // 调用 next.handle()，相当于调用链中的下一个函数 f2
    // 这是中间件链能够继续下去的关键
    next.handle(context);

    long duration = System.currentTimeMillis() - startTime;
    System.out.println("<== Request End: " + context.status() + " in " + duration + "ms");
};
```

**示例 B：一个极简的“鉴权”中间件 (**`f2`**)**

这个中间件检查请求头里是否包含一个特定的 `Authorization` 令牌。

```java
// 伪代码
Middleware authMiddleware = (context, next) -> {
    String token = context.header("Authorization");

    // 实际项目中，这里会有复杂的解密和验证逻辑
    if ("Bearer a-secret-token".equals(token)) {
        // 令牌有效，放行！调用下一个函数 f3
        next.handle(context);
    } else {
        // 令牌无效或不存在，拦截请求，直接返回 401 错误
        // 注意：这里没有调用 next.handle()，处理链在此中断
        context.status(401).text("You shall not pass!");
    }
};
```

**4. 在本项目中的实现**

你需要在你的框架中实现这样的中间件机制：

+ **链式处理**：支持注册一个或多个中间件，形成 `f1(f2(f3(...)))` 这样的处理链。
+ **执行顺序**：中间件应按照注册顺序依次执行。
+ **控制能力**：中间件可以中断（不调用 `next`）或继续（调用 `next`）处理链。

### 2.4. 请求上下文 (Context)
**1. 概念解析：请求的“身份证”与“档案袋”**

如果把每一次用户发来的 HTTP 请求看作一位来访者，那么**请求上下文（Context）**就相当于这位来访者的“身份证”和随身携带的“档案袋”。它是一个在请求处理的整个生命周期中都存在的对象，忠实地记录了关于这次请求的一切信息。

**2. 核心职责与重要性**

+ **信息聚合**：`Context` 将与请求（`Request`）和响应（`Response`）相关的所有数据都封装在一个统一的对象中。这避免了在不同方法之间传来传去大量的参数，让代码更整洁、更易于管理。
+ **数据传递**：它是中间件与最终处理器之间沟通的桥梁。例如，一个身份验证中间件可以从 `Context` 中解析出用户信息，然后将用户对象存入 `Context`，后续的业务逻辑处理器就能直接从中获取，无需重复解析。
+ **状态管理**：它持有请求处理过程中的状态。比如，一个中间件决定中断请求，可以直接通过修改 `Context` 中的响应状态码并结束处理流程。

**3. 在本项目中的实现**

你将创建一个 `Context` 类，它至少要包含以下功能：

+ **统一访问**：提供一个统一的上下文对象，封装请求与响应信息。
+ **可访问信息**：
    - HTTP 方法、路径、查询参数、请求头、请求体。
    - 动态路由匹配的参数（例如，从 `/users/123` 中解析出的 `id=123`）。
    - 可在中间件与处理器之间传递的自定义属性（一个类似 `Map` 的结构）。
+ **便捷的响应方法**：提供如 `ctx.text("...")`、`ctx.json("...")`、`ctx.status(200)` 等便捷方法，让开发者能轻松地构建和发送响应。

这个 `Context` 对象是框架的“血液”，它在路由、中间件和处理器之间流动，串联起整个请求处理过程。精心设计它，将极大提升框架的易用性和扩展性。

### 2.5. 响应与错误处理
+ **标准响应**：处理器能够控制响应状态码和响应体。
+ **404 Not Found**：当没有匹配到任何路由时，框架应自动返回 `404` 状态码。
+ **500 Internal Server Error**：当请求处理过程中发生未捕获的异常时，框架应自动返回 `500` 状态码。

### 2.6. 模板渲染
#### 2.6.1. 为什么需要模板渲染？
让我们从一个最简单的场景开始：服务器需要响应一个 GET 请求，例如用户访问网站首页 `/index`。后端需要返回一个完整的 HTML 页面。

最原始、最粗暴的方式是在后端代码中通过字符串拼接来硬编码一个 HTML：

```bash
// 伪代码
String html = "<html>" +
              "<head><title>首页</title></head>" +
              "<body>" +
                "<h1>欢迎, " + userName + "!</h1>" + // 动态数据
              "</body>" +
            "</html>";
Response.send(html);
```

这种方式的代码非常丑陋，难以维护。更重要的是，它违反了关注点分离（Separation of Concerns）原则：后端开发人员被迫去关心前端页面的具体结构，而前端开发人员无法独立修改页面。

实际上，我们观察到，HTML 的内容和结构基本是不变的，只是其中某些值（比如上面的 `userName`）需要根据每次请求动态变化。

因此，一个更优雅的解决方案浮出水面：**“固定模板打底” + “动态变量插入”**。这就是模板引擎的核心思想。

+ **模板（Template）**：一个预先写好的、包含占位符的 HTML 文件（或其他文本文件）。
+ **数据模型（Data Model）**：一个包含动态数据的对象（比如一个 Map 或 POJO）。
+ **渲染（Render）**：模板引擎将数据模型中的值填充到模板的占位符中，生成最终的 HTML 字符串。

通过这种方式，前端可以专注于编写和设计 HTML 模板，而后端只需准备好数据并调用模板引擎即可，实现了前后端的解耦。

#### 2.6.2. 项目实现要求
+ **模板引擎**：项目需要集成 [FreeMarker](https://freemarker.apache.org/) 作为模板引擎。它是一款成熟、功能强大的 Java 模板引擎。
+ **渲染能力**：框架需要提供一种便捷的方式，允许在路由处理器中调用模板引擎，传入模板名称和数据模型，然后将渲染后的 HTML 作为 HTTP 响应返回给客户端。

例如，处理器可以这样写（伪代码）：

```java
// GET /user/{id}
void getUserProfile(Context ctx) {
    User user = userService.findById(ctx.pathParam("id"));
    // 渲染 "profile.ftl" 模板，并传入一个包含 user 对象的 map
    ctx.render("profile.ftl", Map.of("user", user));
}
```

## 3. 技术实现要点
+ **服务器启动流程**：
    - `Engine` 类作为核心引擎，负责服务器的启动与配置。
    - Netty 的 `ChannelPipeline` 中应至少包含 `HttpServerCodec`（HTTP 编解码）、`HttpObjectAggregator`（HTTP 消息聚合）以及一个自定义的 `HttpHandler`。
+ **请求处理流程**：
    - `HttpHandler` 接收到 `FullHttpRequest` 后，创建统一的 `Context` 对象。
    - 根据请求方法和路径，向 `Router` 查询对应的处理器。
    - 将查询到的处理器与已注册的中间件组合成一个执行链。
    - 顺序执行处理链，并最终将 `Context` 中的响应数据写回客户端。
+ **路由实现**：
    - `Router` 内部使用前缀树数据结构存储路由规则。
    - 在路由匹配过程中，若匹配到动态参数，需将其解析并存入 `Context`。
+ **核心抽象**：
    - `Middleware` (中间件) 和 `Handler` (处理器) 应定义为函数式接口，以支持 Lambda 表达式，简化代码。
